<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Owl of Myths: The Eternal Journey</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            overflow: hidden;
            background-color: #0a0a12;
            color: #e0e0e0;
            touch-action: manipulation;
            height: 100vh;
            font-family: 'Courier New', monospace;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Orientation Warning */
        #orientation-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }

        #orientation-warning img {
            width: 100px;
            height: 100px;
            margin-bottom: 20px;
            animation: rotate 2s infinite linear;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(90deg); }
        }

        /* UI Elements */
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .health-bar-container, .stamina-bar-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 200px;
            height: 30px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #8a5a44;
            border-radius: 5px;
            overflow: hidden;
        }

        .stamina-bar-container { top: 60px; }

        .health-bar, .stamina-bar {
            height: 100%;
            width: 100%;
            transition: width 0.3s;
        }

        .health-bar { background-color: #8a5a44; }
        .stamina-bar { background-color: #5a8a44; }

        .stats-container {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #8a5a44;
            border-radius: 5px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
        }

        .stat-label {
            color: #8a5a44;
            margin-right: 10px;
        }

        .stat-value {
            color: #e0d0a0;
        }

        /* Controls - Mobile Only */
        @media (max-width: 768px) {
            #controls {
                position: absolute;
                bottom: 30px;
                width: 100%;
                display: flex;
                justify-content: space-between;
                pointer-events: auto;
            }

            #movement-controls {
                display: flex;
                flex-direction: column;
                align-items: center;
                margin-left: 20px;
            }

            #action-controls {
                display: flex;
                flex-direction: column;
                align-items: center;
                margin-right: 20px;
            }

            .control-button {
                width: 60px;
                height: 60px;
                background-color: rgba(0, 0, 0, 0.5);
                border: 2px solid #8a5a44;
                border-radius: 50%;
                display: flex;
                justify-content: center;
                align-items: center;
                color: #e0d0a0;
                font-size: 1.5rem;
                cursor: pointer;
                touch-action: manipulation;
                user-select: none;
                transition: all 0.2s;
                margin: 5px;
            }

            .control-button:active {
                background-color: rgba(138, 90, 68, 0.5);
                transform: scale(0.95);
            }

            #joystick-area {
                width: 120px;
                height: 120px;
                background-color: rgba(0, 0, 0, 0.3);
                border-radius: 50%;
                position: relative;
                margin-bottom: 10px;
            }

            #joystick {
                width: 50px;
                height: 50px;
                background-color: rgba(138, 90, 68, 0.7);
                border-radius: 50%;
                position: absolute;
                top: 35px;
                left: 35px;
                touch-action: none;
            }
        }

        /* Menus */
        .menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 20, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: auto;
        }

        .menu-title {
            font-size: 3rem;
            margin-bottom: 2rem;
            color: #8a5a44;
            text-shadow: 3px 3px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .menu-button {
            background-color: #4a3520;
            color: #e0d0a0;
            border: 3px solid #8a5a44;
            border-radius: 8px;
            padding: 12px 24px;
            margin: 8px;
            font-size: 1.2rem;
            cursor: pointer;
            min-width: 200px;
            text-align: center;
            transition: all 0.2s;
            pointer-events: auto;
        }

        .menu-button:hover {
            background-color: #5a4530;
            transform: scale(1.05);
        }

        /* Mythic Book */
        #mythic-book {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
            height: 80%;
            max-height: 600px;
            background-color: #1a0a00;
            border: 3px solid #8a5a44;
            border-radius: 10px;
            z-index: 30;
            padding: 20px;
            overflow: hidden;
            pointer-events: auto;
            flex-direction: column;
        }

        .book-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #8a5a44;
        }

        .book-title {
            font-size: 1.8rem;
            color: #8a5a44;
        }

        .close-button {
            background-color: #4a3520;
            color: #e0d0a0;
            border: 2px solid #8a5a44;
            border-radius: 4px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 1rem;
        }

        .page-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            overflow-y: auto;
            flex-grow: 1;
            padding: 10px;
        }

        .page {
            width: 100%;
            aspect-ratio: 3/4;
            background-color: #1a0a00;
            border: 2px solid #8a5a44;
            padding: 10px;
            cursor: pointer;
            transition: transform 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .page:hover {
            transform: scale(1.05);
        }

        .page-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .page-title {
            font-size: 1rem;
            color: #8a5a44;
            margin-bottom: 5px;
        }

        .page-status {
            font-size: 0.8rem;
            color: #5a5a5a;
        }

        .page-unlocked .page-status {
            color: #5a8a44;
        }

        /* Page Detail View */
        #page-detail {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 500px;
            background-color: #1a0a00;
            border: 3px solid #8a5a44;
            padding: 20px;
            z-index: 40;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
        }

        .detail-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #8a5a44;
        }

        .detail-title {
            font-size: 1.5rem;
            color: #8a5a44;
        }

        .detail-content {
            line-height: 1.5;
            max-height: 300px;
            overflow-y: auto;
        }

        /* Mission Complete Screen */
        #mission-complete {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 20, 0, 0.8);
            z-index: 25;
            text-align: center;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }

        .complete-title {
            font-size: 2.5rem;
            color: #5a8a44;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0 #000;
            animation: pulse 2s infinite;
        }

        .complete-message {
            font-size: 1.2rem;
            margin-bottom: 30px;
            max-width: 80%;
            line-height: 1.6;
        }

        /* Settings Menu */
        #settings-menu {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 500px;
            background-color: #1a0a00;
            border: 3px solid #8a5a44;
            padding: 20px;
            z-index: 30;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
        }

        .settings-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .settings-label {
            font-size: 1rem;
            color: #8a5a44;
        }

        .settings-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .settings-button {
            background-color: #4a3520;
            color: #e0d0a0;
            border: 2px solid #8a5a44;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
        }

        /* Shop Menu */
        #shop-menu {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 600px;
            height: 70%;
            max-height: 500px;
            background-color: #1a0a00;
            border: 3px solid #8a5a44;
            padding: 20px;
            z-index: 30;
            flex-direction: column;
            pointer-events: auto;
            overflow: hidden;
        }

        .shop-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #8a5a44;
        }

        .shop-title {
            font-size: 1.8rem;
            color: #8a5a44;
        }

        .shop-coins {
            font-size: 1.2rem;
            color: #e0d0a0;
        }

        .shop-items {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            overflow-y: auto;
            flex-grow: 1;
            padding: 10px;
        }

        .shop-item {
            background-color: #2a1a00;
            border: 2px solid #8a5a44;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .item-icon {
            font-size: 2rem;
        }

        .item-name {
            font-size: 1rem;
            color: #8a5a44;
            text-align: center;
        }

        .item-price {
            font-size: 0.9rem;
            color: #e0d0a0;
        }

        .item-button {
            background-color: #4a3520;
            color: #e0d0a0;
            border: 1px solid #8a5a44;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 0.8rem;
            width: 100%;
        }

        .item-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Environment Info */
        #environment-info {
            position: absolute;
            bottom: 120px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #8a5a44;
            border-radius: 5px;
            padding: 10px;
            font-size: 0.9rem;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .environment-item {
            display: flex;
        }

        .environment-label {
            color: #8a5a44;
            margin-right: 10px;
            min-width: 70px;
        }

        .environment-value {
            color: #e0d0a0;
        }

        /* Performance Optimizations */
        @media (max-width: 768px) {
            .menu-title {
                font-size: 2rem;
            }

            .menu-button {
                min-width: 160px;
                padding: 10px 20px;
                font-size: 1rem;
            }

            .health-bar-container, .stamina-bar-container {
                width: 150px;
                height: 25px;
            }

            .stats-container {
                top: 10px;
                right: 10px;
                padding: 8px;
            }

            .stat-item {
                font-size: 12px;
            }
        }

        @media (orientation: portrait) {
            #orientation-warning {
                display: flex;
            }
        }

        /* Food Indicator */
        #food-indicator {
            position: absolute;
            top: 100px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #8a5a44;
            border-radius: 5px;
            padding: 10px;
            font-size: 0.9rem;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .food-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .food-icon {
            margin-right: 8px;
            font-size: 1.2rem;
        }

        .food-count {
            color: #e0d0a0;
        }
    </style>
</head>
<body>
    <!-- Orientation Warning -->
    <div id="orientation-warning">
        <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZmlsbD0iI2UwZDBhMCIgZD0iTTksN0gxNVYxN0g5VjdNMTksMTlIMVY1SDE5VjE5WiIvPjwvc3ZnPg==" alt="Rotate Device">
        <h2>Please rotate your device</h2>
        <p>This game is designed to be played in landscape mode.</p>
    </div>

    <!-- Game Container -->
    <div id="game-container">
        <canvas id="game-canvas"></canvas>

        <!-- UI Container -->
        <div id="ui-container">
            <!-- Health and Stamina Bars -->
            <div class="health-bar-container">
                <div class="health-bar" id="health-bar"></div>
            </div>
            <div class="stamina-bar-container">
                <div class="stamina-bar" id="stamina-bar"></div>
            </div>

            <!-- Food Inventory -->
            <div id="food-indicator">
                <div class="food-item">
                    <span class="food-icon">🍎</span>
                    <span class="food-count" id="apple-count">0</span>
                </div>
                <div class="food-item">
                    <span class="food-icon">🍗</span>
                    <span class="food-count" id="meat-count">0</span>
                </div>
                <div class="food-item">
                    <span class="food-icon">🍄</span>
                    <span class="food-count" id="mushroom-count">0</span>
                </div>
            </div>

            <!-- Stats -->
            <div class="stats-container">
                <div class="stat-item">
                    <span class="stat-label">DISTANCE</span>
                    <span class="stat-value" id="distance-value">0 KM</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">TARGET</span>
                    <span class="stat-value" id="target-value">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">COINS</span>
                    <span class="stat-value" id="coins-value">0</span>
                </div>
            </div>

            <!-- Environment Info -->
            <div id="environment-info">
                <div class="environment-item">
                    <span class="environment-label">BIOME</span>
                    <span class="environment-value" id="biome-value">-</span>
                </div>
                <div class="environment-item">
                    <span class="environment-label">SEASON</span>
                    <span class="environment-value" id="season-value">-</span>
                </div>
                <div class="environment-item">
                    <span class="environment-label">WEATHER</span>
                    <span class="environment-value" id="weather-value">-</span>
                </div>
            </div>

            <!-- Mobile Controls -->
            <div id="controls">
                <div id="movement-controls">
                    <div id="joystick-area">
                        <div id="joystick"></div>
                    </div>
                    <div class="control-button" id="up-button">↑</div>
                </div>
                <div id="action-controls">
                    <div class="control-button" id="action-button">A</div>
                    <div class="control-button" id="menu-button">M</div>
                </div>
            </div>
        </div>

        <!-- Main Menu -->
        <div id="main-menu" class="menu">
            <h1 class="menu-title">OWL OF MYTHS</h1>
            <button class="menu-button" id="new-game-button">NEW JOURNEY</button>
            <button class="menu-button" id="continue-button">CONTINUE</button>
            <button class="menu-button" id="mythic-book-button">MYTHIC BOOK</button>
            <button class="menu-button" id="shop-button">SHOP</button>
            <button class="menu-button" id="settings-button">SETTINGS</button>
        </div>

        <!-- Pause Menu -->
        <div id="pause-menu" class="menu">
            <h1 class="menu-title">PAUSED</h1>
            <button class="menu-button" id="resume-button">RESUME</button>
            <button class="menu-button" id="save-exit-button">SAVE & EXIT</button>
            <button class="menu-button" id="book-from-pause">MYTHIC BOOK</button>
            <button class="menu-button" id="shop-from-pause">SHOP</button>
        </div>

        <!-- Mythic Book -->
        <div id="mythic-book">
            <div class="book-header">
                <h2 class="book-title">MYTHIC BOOK</h2>
                <button class="close-button" id="close-book-button">CLOSE</button>
            </div>
            <div class="page-container" id="page-container">
                <!-- Pages will be generated here -->
            </div>
        </div>

        <!-- Page Detail View -->
        <div id="page-detail">
            <div class="detail-header">
                <h3 class="detail-title" id="detail-title">-</h3>
                <button class="close-button" id="close-detail-button">CLOSE</button>
            </div>
            <div class="detail-content" id="detail-content">
                <!-- Page content will be loaded here -->
            </div>
        </div>

        <!-- Mission Complete Screen -->
        <div id="mission-complete">
            <h2 class="complete-title">MISSION COMPLETE</h2>
            <p class="complete-message" id="complete-message"></p>
            <button class="menu-button" id="continue-journey-button">CONTINUE JOURNEY</button>
        </div>

        <!-- Settings Menu -->
        <div id="settings-menu">
            <div class="book-header">
                <h2 class="book-title">SETTINGS</h2>
                <button class="close-button" id="close-settings-button">CLOSE</button>
            </div>

            <div class="settings-item">
                <span class="settings-label">Music</span>
                <div class="settings-control">
                    <button class="settings-button" id="music-toggle">ON</button>
                </div>
            </div>

            <div class="settings-item">
                <span class="settings-label">Sound Effects</span>
                <div class="settings-control">
                    <button class="settings-button" id="sound-toggle">ON</button>
                </div>
            </div>

            <div class="settings-item">
                <span class="settings-label">Difficulty</span>
                <div class="settings-control">
                    <button class="settings-button" id="difficulty-button">NORMAL</button>
                </div>
            </div>

            <div class="settings-item">
                <span class="settings-label">Auto-Save</span>
                <div class="settings-control">
                    <button class="settings-button" id="autosave-toggle">ON</button>
                </div>
            </div>

            <div class="settings-item">
                <span class="settings-label">Controls</span>
                <div class="settings-control">
                    <button class="settings-button" id="controls-help-button">HELP</button>
                </div>
            </div>

            <button class="menu-button" id="reset-game-button" style="margin-top: 20px;">RESET GAME</button>
        </div>

        <!-- Shop Menu -->
        <div id="shop-menu">
            <div class="shop-header">
                <h2 class="shop-title">MYTHIC SHOP</h2>
                <div class="shop-coins">COINS: <span id="shop-coins-value">0</span></div>
            </div>

            <div class="shop-items" id="shop-items">
                <!-- Shop items will be generated here -->
            </div>
            <button class="close-button" id="close-shop-button" style="margin-top: 20px; align-self: center;">CLOSE SHOP</button>
        </div>
    </div>

    <script>
        // Game Constants
        const GAME_VERSION = "2.0.0";
        const BIOMES = ['forest', 'desert', 'mountains', 'swamp', 'caves'];
        const SEASONS = ['spring', 'summer', 'autumn', 'winter'];
        const WEATHER = ['clear', 'rain', 'storm', 'fog', 'heatwave', 'snow'];
        const PREDATORS = ['tiger', 'eagle', 'fox', 'wolf', 'snake', 'chameleon'];
        const DIFFICULTIES = ['easy', 'normal', 'hard', 'extreme'];
        const FOOD_TYPES = ['apple', 'meat', 'mushroom'];

        // Performance settings
        const PERFORMANCE = {
            terrainDetail: window.innerWidth > 768 ? 'high' : 'medium',
            shadowQuality: window.innerWidth > 768 ? 1024 : 512,
            particleCount: window.innerWidth > 768 ? 1000 : 500,
            physicsSteps: window.innerWidth > 768 ? 3 : 2
        };

        // Game Data
        const PREDATOR_DATA = {
            tiger: {
                name: "Tiger",
                difficulty: 3,
                biome: 'forest',
                description: "The tiger's roar breaks silence, but fears the cry of dusk.",
                weakness: "Avoid open ground. Use trees to stay above its reach.",
                tactics: "Lure it near cliffs or water where it moves slower.",
                speed: 1.5,
                health: 100,
                reward: 30
            },
            eagle: {
                name: "Eagle",
                difficulty: 4,
                biome: 'mountains',
                description: "The eagle sees all but the shadow beneath its wings.",
                weakness: "Fly low when it circles. Attack when it dives.",
                tactics: "Use clouds or rock formations to break line of sight.",
                speed: 2.0,
                health: 80,
                reward: 40
            },
            fox: {
                name: "Fox",
                difficulty: 2,
                biome: 'forest',
                description: "The fox's cunning is matched only by its fear of truth.",
                weakness: "It always returns to its den after three turns.",
                tactics: "Track its den and ambush it there.",
                speed: 1.8,
                health: 70,
                reward: 20
            },
            wolf: {
                name: "Wolf",
                difficulty: 3,
                biome: 'mountains',
                description: "The wolf hunts as one, but fears the lone howl.",
                weakness: "Separate it from the pack to weaken it.",
                tactics: "Use narrow passages where numbers don't help.",
                speed: 1.7,
                health: 90,
                reward: 35
            },
            snake: {
                name: "Snake",
                difficulty: 2,
                biome: 'swamp',
                description: "The snake strikes without sound but fears the vibration.",
                weakness: "It can't track you if you don't move on the ground.",
                tactics: "Stay airborne and attack from above.",
                speed: 1.3,
                health: 60,
                reward: 25
            },
            chameleon: {
                name: "Chameleon",
                difficulty: 5,
                biome: 'forest',
                description: "The chameleon hides in plain sight but fears the mirror.",
                weakness: "It can't change color when moving quickly.",
                tactics: "Force it to move rapidly to reveal itself.",
                speed: 1.2,
                health: 50,
                reward: 50
            }
        };

        const BIOME_DATA = {
            forest: {
                name: "Ancient Forest",
                hazards: ['thick foliage', 'falling branches', 'hidden predators'],
                staminaEffect: 1.0,
                visibility: 0.8,
                color: 0x0a300a,
                terrainHeight: 5,
                treeDensity: 0.8,
                foodSpawn: ['apple', 'mushroom']
            },
            desert: {
                name: "Scorching Desert",
                hazards: ['sandstorms', 'heat exhaustion', 'quicksand'],
                staminaEffect: 0.6,
                visibility: 1.0,
                color: 0xd4b16a,
                terrainHeight: 2,
                treeDensity: 0.1,
                foodSpawn: []
            },
            mountains: {
                name: "Mystic Mountains",
                hazards: ['strong winds', 'avalanches', 'thin air'],
                staminaEffect: 0.8,
                visibility: 0.9,
                color: 0x3a4a6b,
                terrainHeight: 15,
                treeDensity: 0.5,
                foodSpawn: ['meat']
            },
            swamp: {
                name: "Murky Swamp",
                hazards: ['deep water', 'toxic gases', 'sinking mud'],
                staminaEffect: 0.7,
                visibility: 0.6,
                color: 0x2a4a3a,
                terrainHeight: 3,
                treeDensity: 0.6,
                foodSpawn: ['mushroom']
            },
            caves: {
                name: "Dark Caves",
                hazards: ['complete darkness', 'echo confusion', 'falling rocks'],
                staminaEffect: 0.9,
                visibility: 0.3,
                color: 0x1a1a1a,
                terrainHeight: 8,
                treeDensity: 0.2,
                foodSpawn: ['mushroom']
            }
        };

        const SEASON_DATA = {
            spring: {
                name: "Spring",
                effect: "New growth provides hiding spots but also conceals predators.",
                staminaEffect: 1.1,
                visibility: 0.8,
                particleColor: 0x44aa44,
                particleDensity: 0.3
            },
            summer: {
                name: "Summer",
                effect: "Heat can exhaust you quickly but dries up some hazards.",
                staminaEffect: 0.8,
                visibility: 0.9,
                particleColor: 0xdddd00,
                particleDensity: 0.1
            },
            autumn: {
                name: "Autumn",
                effect: "Falling leaves reveal movement but provide camouflage.",
                staminaEffect: 1.0,
                visibility: 0.7,
                particleColor: 0xaa5500,
                particleDensity: 0.5
            },
            winter: {
                name: "Winter",
                effect: "Cold saps stamina but tracks are easier to follow.",
                staminaEffect: 0.7,
                visibility: 0.6,
                particleColor: 0xffffff,
                particleDensity: 0.7
            }
        };

        const WEATHER_DATA = {
            clear: {
                name: "Clear",
                effect: "Normal conditions with no special effects.",
                staminaEffect: 1.0,
                visibility: 1.0,
                particleDensity: 0
            },
            rain: {
                name: "Rain",
                effect: "Reduces visibility and makes surfaces slippery.",
                staminaEffect: 0.9,
                visibility: 0.7,
                particleDensity: 0.8,
                particleColor: 0xaaaaaa,
                particleSpeed: 0.5
            },
            storm: {
                name: "Storm",
                effect: "Dangerous lightning and strong winds.",
                staminaEffect: 0.8,
                visibility: 0.5,
                particleDensity: 1.0,
                particleColor: 0x666666,
                particleSpeed: 1.0,
                lightningChance: 0.01
            },
            fog: {
                name: "Fog",
                effect: "Greatly reduces visibility.",
                staminaEffect: 1.0,
                visibility: 0.3,
                particleDensity: 0.6,
                particleColor: 0xcccccc,
                particleSpeed: 0.1
            },
            heatwave: {
                name: "Heatwave",
                effect: "Rapidly drains stamina.",
                staminaEffect: 0.6,
                visibility: 0.9,
                particleDensity: 0.2,
                particleColor: 0xff6600,
                particleSpeed: 0.3
            },
            snow: {
                name: "Snow",
                effect: "Reduces visibility and movement speed.",
                staminaEffect: 0.7,
                visibility: 0.6,
                particleDensity: 0.7,
                particleColor: 0xffffff,
                particleSpeed: 0.2
            }
        };
// Add a default weather type
WEATHER_DATA.default = {
    name: "Unknown",
    effect: "Unknown weather conditions.",
    staminaEffect: 1.0,
    visibility: 1.0,
    particleDensity: 0,
    lightningChance: 0
};

        const FOOD_DATA = {
            apple: {
                name: "Apple",
                icon: "🍎",
                healthRestore: 10,
                staminaRestore: 5,
                rarity: 0.7
            },
            meat: {
                name: "Meat",
                icon: "🍗",
                healthRestore: 20,
                staminaRestore: 10,
                rarity: 0.5
            },
            mushroom: {
                name: "Mushroom",
                icon: "🍄",
                healthRestore: 5,
                staminaRestore: 15,
                rarity: 0.8
            }
        };

        const SHOP_ITEMS = [
            {
                id: 'stamina-upgrade',
                name: "Stamina Upgrade",
                description: "Permanently increases your maximum stamina by 20 points.",
                price: 50,
                icon: "💪",
                effect: (gameState) => {
                    gameState.player.maxStamina += 20;
                    gameState.player.stamina = gameState.player.maxStamina;
                }
            },
            {
                id: 'health-upgrade',
                name: "Health Upgrade",
                description: "Permanently increases your maximum health by 10 points.",
                price: 60,
                icon: "❤️",
                effect: (gameState) => {
                    gameState.player.maxHealth += 10;
                    gameState.player.health = gameState.player.maxHealth;
                }
            },
            {
                id: 'speed-upgrade',
                name: "Speed Upgrade",
                description: "Permanently increases your movement speed by 10%.",
                price: 70,
                icon: "⚡",
                effect: (gameState) => {
                    gameState.player.speed *= 1.1;
                }
            },
            {
                id: 'heat-resistance',
                name: "Heat Resistance",
                description: "Reduces stamina drain in hot environments by 30%.",
                price: 40,
                icon: "☀️",
                effect: (gameState) => {
                    gameState.player.upgrades.heatResistance = true;
                }
            },
            {
                id: 'cold-resistance',
                name: "Cold Resistance",
                description: "Reduces stamina drain in cold environments by 30%.",
                price: 40,
                icon: "❄️",
                effect: (gameState) => {
                    gameState.player.upgrades.coldResistance = true;
                }
            },
            {
                id: 'chameleon-detector',
                name: "Chameleon Detector",
                description: "Reveals chameleons even when they're camouflaged.",
                price: 80,
                icon: "👁️",
                effect: (gameState) => {
                    gameState.player.upgrades.chameleonDetector = true;
                }
            },
            {
                id: 'health-potion',
                name: "Health Potion",
                description: "Restores 30 health points immediately.",
                price: 30,
                icon: "🧪",
                effect: (gameState) => {
                    gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + 30);
                },
                consumable: true
            },
            {
                id: 'stamina-potion',
                name: "Stamina Potion",
                description: "Restores 40 stamina points immediately.",
                price: 25,
                icon: "🧃",
                effect: (gameState) => {
                    gameState.player.stamina = Math.min(gameState.player.maxStamina, gameState.player.stamina + 40);
                },
                consumable: true
            },
            {
                id: 'food-pack',
                name: "Food Pack",
                description: "Gives 3 random food items to restore health and stamina.",
                price: 20,
                icon: "🍱",
                effect: (gameState) => {
                    for (let i = 0; i < 3; i++) {
                        const foodType = FOOD_TYPES[Math.floor(Math.random() * FOOD_TYPES.length)];
                        gameState.player.inventory[foodType] = (gameState.player.inventory[foodType] || 0) + 1;
                    }
                    updateFoodUI();
                },
                consumable: true
            },
            {
                id: 'apple',
                name: "Apple",
                description: "Restores 10 health and 5 stamina.",
                price: 5,
                icon: "🍎",
                effect: (gameState) => {
                    gameState.player.inventory.apple = (gameState.player.inventory.apple || 0) + 1;
                    updateFoodUI();
                },
                consumable: true
            },
            {
                id: 'meat',
                name: "Meat",
                description: "Restores 20 health and 10 stamina.",
                price: 10,
                icon: "🍗",
                effect: (gameState) => {
                    gameState.player.inventory.meat = (gameState.player.inventory.meat || 0) + 1;
                    updateFoodUI();
                },
                consumable: true
            },
            {
                id: 'mushroom',
                name: "Mushroom",
                description: "Restores 5 health and 15 stamina.",
                price: 7,
                icon: "🍄",
                effect: (gameState) => {
                    gameState.player.inventory.mushroom = (gameState.player.inventory.mushroom || 0) + 1;
                    updateFoodUI();
                },
                consumable: true
            }
        ];

        // Game State
        let gameState = {
            player: {
                health: 100,
                maxHealth: 100,
                stamina: 100,
                maxStamina: 100,
                speed: 5,
                coins: 0,
                distance: 0,
                position: { x: 0, y: 10, z: 0 },
                velocity: { x: 0, y: 0, z: 0 },
                upgrades: {
                    staminaRecovery: 1,
                    speed: 1,
                    vision: 1,
                    heatResistance: false,
                    coldResistance: false,
                    chameleonDetector: false
                },
                unlockedPredators: [],
                unlockedPages: [],
                inventory: {
                    apple: 0,
                    meat: 0,
                    mushroom: 0
                }
            },
            currentMission: {
                predator: null,
                biome: null,
                season: null,
                weather: null,
                started: false,
                completed: false,
                startTime: 0,
                endTime: 0,
                predatorPosition: { x: 50, y: 0, z: 0 },
                predatorHealth: 0,
                foodItems: []
            },
            settings: {
                sound: true,
                music: true,
                difficulty: 'normal',
                autoSave: true,
                controls: 'buttons' // 'buttons' or 'joystick'
            },
            stats: {
                totalDistance: 0,
                predatorsCaptured: 0,
                deaths: 0,
                playTime: 0,
                coinsCollected: 0,
                upgradesPurchased: 0,
                foodConsumed: 0
            }
        };

        // Three.js Variables
        let scene, camera, renderer, world, clock, owl, predator, terrain, weatherParticles, lightning;
        let directionalLight, ambientLight, hemisphereLight;
        let controls = {
            left: false,
            right: false,
            up: false,
            action: false,
            menu: false,
            joystick: { x: 0, y: 0 }
        };

        // Physics Variables
        let physicsWorld;
        const fixedTimeStep = 1.0 / 60.0;
        const maxSubSteps = PERFORMANCE.physicsSteps;

        // DOM Elements
        const elements = {
            gameContainer: document.getElementById('game-container'),
            gameCanvas: document.getElementById('game-canvas'),
            mainMenu: document.getElementById('main-menu'),
            pauseMenu: document.getElementById('pause-menu'),
            mythicBook: document.getElementById('mythic-book'),
            pageDetail: document.getElementById('page-detail'),
            missionComplete: document.getElementById('mission-complete'),
            settingsMenu: document.getElementById('settings-menu'),
            shopMenu: document.getElementById('shop-menu'),
            healthBar: document.getElementById('health-bar'),
            staminaBar: document.getElementById('stamina-bar'),
            distanceValue: document.getElementById('distance-value'),
            targetValue: document.getElementById('target-value'),
            coinsValue: document.getElementById('coins-value'),
            completeMessage: document.getElementById('complete-message'),
            pageContainer: document.getElementById('page-container'),
            detailTitle: document.getElementById('detail-title'),
            detailContent: document.getElementById('detail-content'),
            orientationWarning: document.getElementById('orientation-warning'),
            biomeValue: document.getElementById('biome-value'),
            seasonValue: document.getElementById('season-value'),
            weatherValue: document.getElementById('weather-value'),
            shopCoinsValue: document.getElementById('shop-coins-value'),
            shopItems: document.getElementById('shop-items'),
            appleCount: document.getElementById('apple-count'),
            meatCount: document.getElementById('meat-count'),
            mushroomCount: document.getElementById('mushroom-count'),
            joystick: document.getElementById('joystick'),
            joystickArea: document.getElementById('joystick-area')
        };

        // Buttons
        const buttons = {
            newGame: document.getElementById('new-game-button'),
            continue: document.getElementById('continue-button'),
            mythicBook: document.getElementById('mythic-book-button'),
            shop: document.getElementById('shop-button'),
            shopFromPause: document.getElementById('shop-from-pause'),
            settings: document.getElementById('settings-button'),
            resume: document.getElementById('resume-button'),
            saveExit: document.getElementById('save-exit-button'),
            bookFromPause: document.getElementById('book-from-pause'),
            closeBook: document.getElementById('close-book-button'),
            closeDetail: document.getElementById('close-detail-button'),
            continueJourney: document.getElementById('continue-journey-button'),
            left: document.getElementById('left-button'),
            right: document.getElementById('right-button'),
            up: document.getElementById('up-button'),
            action: document.getElementById('action-button'),
            menu: document.getElementById('menu-button'),
            musicToggle: document.getElementById('music-toggle'),
            soundToggle: document.getElementById('sound-toggle'),
            difficultyButton: document.getElementById('difficulty-button'),
            autosaveToggle: document.getElementById('autosave-toggle'),
            controlsHelpButton: document.getElementById('controls-help-button'),
            resetGameButton: document.getElementById('reset-game-button'),
            closeSettingsButton: document.getElementById('close-settings-button'),
            closeShopButton: document.getElementById('close-shop-button')
        };

        // Game Variables
        let gameRunning = false;
        let lastTime = 0;
        let keys = {};
        let joystickActive = false;
        let joystickStartPos = { x: 0, y: 0 };

        // Audio
        const audio = {
            flap: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-bird-flapping-wings-2134.mp3'),
            wind: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-wind-against-a-window-1495.mp3'),
            rain: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-rain-loop-1244.mp3'),
            thunder: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-thunder-strike-1680.mp3'),
            success: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-achievement-bell-600.mp3'),
            damage: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-player-jumping-in-a-video-game-2043.mp3'),
            eat: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-eating-or-chewing-1273.mp3'),
            background: new Audio('https://assets.mixkit.co/music/preview/mixkit-ethereal-fairy-pipe-consort-1450.mp3')
        };

        // Initialize Three.js scene
        function initThreeJS() {
            // Create scene with performance settings
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.01);

            // Create camera with aspect ratio based on device
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 30);
            camera.lookAt(0, 10, 0);

            // Create renderer with device-appropriate settings
            renderer = new THREE.WebGLRenderer({
                canvas: elements.gameCanvas,
                antialias: PERFORMANCE.terrainDetail === 'high',
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.shadowMap.autoUpdate = false; // Manual shadow updates for performance

            // Add optimized lights
            directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = PERFORMANCE.shadowQuality;
            directionalLight.shadow.mapSize.height = PERFORMANCE.shadowQuality;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);

            ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.5);
            scene.add(hemisphereLight);

            // Create clock for animations
            clock = new THREE.Clock();

            // Initialize physics world
            initPhysics();

            // Handle window resize
            window.addEventListener('resize', onWindowResize, { passive: true });
        }

        function initPhysics() {
            // Setup Cannon.js physics world with performance settings
            physicsWorld = new CANNON.World();
            physicsWorld.gravity.set(0, -9.82, 0);
            physicsWorld.broadphase = new CANNON.NaiveBroadphase();
            physicsWorld.solver.iterations = 8; // Reduced for performance

            // Create ground plane
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0 });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            physicsWorld.addBody(groundBody);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Create optimized terrain
        function createTerrain() {
            const biome = BIOME_DATA[gameState.currentMission.biome];
            const segments = PERFORMANCE.terrainDetail === 'high' ? 100 : 50;
            const geometry = new THREE.PlaneGeometry(200, 200, segments, segments);

            // Create height variations with optimized noise
            const position = geometry.attributes.position;
            for (let i = 0; i < position.count; i++) {
                const x = position.getX(i);
                const z = position.getZ(i);
                
                // Simpler noise function for performance
                let height = biome.terrainHeight * (
                    Math.sin(x * 0.05) * Math.cos(z * 0.05) +
                    0.5 * Math.sin(x * 0.1) * Math.cos(z * 0.1)
                );

                position.setY(i, height);
            }

            geometry.computeVertexNormals();

            const material = new THREE.MeshStandardMaterial({
                color: biome.color,
                side: THREE.DoubleSide,
                flatShading: PERFORMANCE.terrainDetail !== 'high'
            });

            terrain = new THREE.Mesh(geometry, material);
            terrain.rotation.x = -Math.PI / 2;
            terrain.receiveShadow = true;
            scene.add(terrain);

            // Add trees for forest biome with performance considerations
            if (biome.treeDensity > 0) {
                const treeCount = Math.floor(100 * biome.treeDensity * (PERFORMANCE.terrainDetail === 'high' ? 1 : 0.7));
                
                // Use instanced mesh for better performance if many trees
                if (treeCount > 50 && PERFORMANCE.terrainDetail === 'high') {
                    const treeGeometry = createTreeGeometry();
                    const treeMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                    const treeTopMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
                    
                    const treeInstances = new THREE.Group();
                    for (let i = 0; i < treeCount; i++) {
                        const tree = new THREE.Mesh(treeGeometry, [treeMaterial, treeTopMaterial]);
                        tree.position.x = Math.random() * 180 - 90;
                        tree.position.z = Math.random() * 180 - 90;
                        tree.position.y = getTerrainHeight(tree.position.x, tree.position.z);
                        tree.castShadow = true;
                        treeInstances.add(tree);
                    }
                    scene.add(treeInstances);
                } else {
                    // Fewer trees - create individually
                    for (let i = 0; i < treeCount; i++) {
                        const tree = createTree();
                        tree.position.x = Math.random() * 180 - 90;
                        tree.position.z = Math.random() * 180 - 90;
                        tree.position.y = getTerrainHeight(tree.position.x, tree.position.z);
                        scene.add(tree);
                    }
                }
            }

            // Spawn food items in the environment
            spawnFoodItems();
        }

        function createTreeGeometry() {
            // Create combined geometry for better performance with instancing
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 5, 8);
            const leavesGeometry = new THREE.SphereGeometry(3, 8, 8);
            
            // Combine geometries
            trunkGeometry.translate(0, 2.5, 0);
            leavesGeometry.translate(0, 5, 0);
            
            const combinedGeometry = new THREE.BufferGeometry();
            const trunkAttr = trunkGeometry.attributes;
            const leavesAttr = leavesGeometry.attributes;
            
            // Combine position attributes
            const position = new Float32Array(trunkAttr.position.count + leavesAttr.position.count);
            position.set(trunkAttr.position.array, 0);
            position.set(leavesAttr.position.array, trunkAttr.position.count * 3);
            combinedGeometry.setAttribute('position', new THREE.BufferAttribute(position, 3));
            
            // Create material index for each part
            const index = new Uint16Array(trunkAttr.position.count / 3 + leavesAttr.position.count / 3);
            index.fill(0, 0, trunkAttr.position.count / 3); // Trunk material index
            index.fill(1, trunkAttr.position.count / 3); // Leaves material index
            
            return combinedGeometry;
        }

        function createTree() {
            const group = new THREE.Group();

            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 5, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2.5;
            trunk.castShadow = true;
            group.add(trunk);

            // Leaves
            const leavesGeometry = new THREE.SphereGeometry(3, 8, 8);
            const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = 5;
            leaves.castShadow = true;
            group.add(leaves);

            return group;
        }

        function spawnFoodItems() {
            const biome = BIOME_DATA[gameState.currentMission.biome];
            gameState.currentMission.foodItems = [];
            
            // Spawn food based on biome
            biome.foodSpawn.forEach(foodType => {
                const count = Math.floor(5 * FOOD_DATA[foodType].rarity);
                
                for (let i = 0; i < count; i++) {
                    const food = {
                        type: foodType,
                        position: {
                            x: Math.random() * 180 - 90,
                            z: Math.random() * 180 - 90,
                            y: getTerrainHeight(x, z) + 0.5
                        },
                        collected: false
                    };
                    gameState.currentMission.foodItems.push(food);
                    
                    // Create visual representation (simplified for performance)
                    const foodGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                    const foodMaterial = new THREE.MeshStandardMaterial({ 
                        color: foodType === 'apple' ? 0xff0000 : 
                               foodType === 'meat' ? 0x8B0000 : 0x8B4513 
                    });
                    const foodMesh = new THREE.Mesh(foodGeometry, foodMaterial);
                    foodMesh.position.set(food.position.x, food.position.y, food.position.z);
                    foodMesh.userData.foodItem = food;
                    scene.add(foodMesh);
                }
            });
        }

        function getTerrainHeight(x, z) {
            if (!terrain) return 0;

            // Convert world coordinates to local terrain coordinates
            const localX = x - terrain.position.x;
            const localZ = z - terrain.position.z;
            
            // Simplified height calculation for performance
            const geometry = terrain.geometry;
            const position = geometry.attributes.position;
            
            // Find approximate height by sampling nearest vertices
            let minDist = Infinity;
            let height = 0;
            
            // Sample a subset of vertices for performance
            for (let i = 0; i < position.count; i += Math.floor(position.count / 100)) {
                const vx = position.getX(i);
                const vz = position.getZ(i);
                const dist = Math.sqrt((vx - localX) ** 2 + (vz - localZ) ** 2);
                
                if (dist < minDist) {
                    minDist = dist;
                    height = position.getY(i);
                }
            }
            
            return height;
        }

        // Create optimized owl character
        function createOwl() {
            const group = new THREE.Group();

            // Use simpler geometry for mobile
            const isMobile = window.innerWidth <= 768;
            
            // Body (sphere)
            const bodyGeometry = new THREE.SphereGeometry(1.5, isMobile ? 12 : 16, isMobile ? 12 : 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x8a5a44 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = !isMobile; // Disable shadows on mobile for performance
            group.add(body);

            // Head (sphere)
            const headGeometry = new THREE.SphereGeometry(1, isMobile ? 10 : 16, isMobile ? 10 : 16);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0x8a5a44 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.5;
            head.castShadow = !isMobile;
            group.add(head);

            // Eyes (spheres)
            const eyeGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.4, 1.6, 0.8);
            group.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.4, 1.6, 0.8);
            group.add(rightEye);

            // Pupils (spheres)
            const pupilGeometry = new THREE.SphereGeometry(0.15, 6, 6);
            const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });

            const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            leftPupil.position.set(-0.4, 1.6, 1.1);
            group.add(leftPupil);

            const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            rightPupil.position.set(0.4, 1.6, 1.1);
            group.add(rightPupil);

            // Beak (cone)
            const beakGeometry = new THREE.ConeGeometry(0.2, 0.5, 8);
            const beakMaterial = new THREE.MeshStandardMaterial({ color: 0xe8a040 });
            const beak = new THREE.Mesh(beakGeometry, beakMaterial);
            beak.position.set(0, 1.4, 1.1);
            beak.rotation.x = Math.PI / 2;
            group.add(beak);

            // Wings (hemispheres)
            const wingGeometry = new THREE.SphereGeometry(1.2, 8, 8, 0, Math.PI, 0, Math.PI / 2);
            const wingMaterial = new THREE.MeshStandardMaterial({ color: 0x6a4a34 });

            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-1.5, 0.5, 0);
            leftWing.rotation.z = Math.PI / 4;
            leftWing.castShadow = !isMobile;
            group.add(leftWing);

            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(1.5, 0.5, 0);
            rightWing.rotation.z = -Math.PI / 4;
            rightWing.castShadow = !isMobile;
            group.add(rightWing);

            // Tail (cone)
            const tailGeometry = new THREE.ConeGeometry(0.5, 1.5, 8);
            const tailMaterial = new THREE.MeshStandardMaterial({ color: 0x6a4a34 });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.position.set(0, 0, -1.5);
            tail.rotation.x = Math.PI / 2;
            group.add(tail);

            owl = group;
            owl.position.copy(new THREE.Vector3(
                gameState.player.position.x,
                gameState.player.position.y,
                gameState.player.position.z
            ));
            scene.add(owl);

            // Create physics body for owl (simplified for performance)
            const owlShape = new CANNON.Sphere(1.5);
            const owlBody = new CANNON.Body({ mass: 1 });
            owlBody.addShape(owlShape);
            owlBody.position.copy(owl.position);
            physicsWorld.addBody(owlBody);

            return owl;
        }

        // Create optimized predator
        function createPredator() {
            if (!gameState.currentMission.predator) return;

            const predatorType = gameState.currentMission.predator;
            const predatorInfo = PREDATOR_DATA[predatorType];
            const isMobile = window.innerWidth <= 768;

            const group = new THREE.Group();

            switch (predatorType) {
                case 'tiger':
                    // Simplified tiger model
                    const tigerBodyGeometry = new THREE.BoxGeometry(3, 1.5, 2);
                    const tigerBodyMaterial = new THREE.MeshStandardMaterial({ color: 0xe8a040 });
                    const tigerBody = new THREE.Mesh(tigerBodyGeometry, tigerBodyMaterial);
                    tigerBody.castShadow = !isMobile;
                    group.add(tigerBody);

                    // Head
                    const tigerHeadGeometry = new THREE.BoxGeometry(1.5, 1, 1);
                    const tigerHead = new THREE.Mesh(tigerHeadGeometry, tigerBodyMaterial);
                    tigerHead.position.set(-1.8, 0.5, 0);
                    group.add(tigerHead);

                    // Stripes (simplified)
                    const stripeGeometry = new THREE.BoxGeometry(0.2, 0.1, 2.2);
                    const stripeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                    for (let i = 0; i < 3; i++) { // Reduced stripe count
                        const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                        stripe.position.set(-2 + i * 1.5, 0.8, 0);
                        stripe.rotation.z = Math.PI / 4;
                        group.add(stripe);
                    }

                    // Legs
                    const legGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 6);
                    for (let i = 0; i < 4; i++) {
                        const leg = new THREE.Mesh(legGeometry, tigerBodyMaterial);
                        const x = i < 2 ? -1 : 1;
                        const z = i % 2 === 0 ? -0.8 : 0.8;
                        leg.position.set(x, -1, z);
                        leg.rotation.x = Math.PI / 2;
                        group.add(leg);
                    }

                    // Tail
                    const tailGeometry = new THREE.CylinderGeometry(0.2, 0.1, 2, 6);
                    const tail = new THREE.Mesh(tailGeometry, tigerBodyMaterial);
                    tail.position.set(2, -0.5, 0);
                    tail.rotation.z = Math.PI / 4;
                    group.add(tail);
                    break;

                case 'eagle':
                    // Simplified eagle model
                    const eagleBodyGeometry = new THREE.SphereGeometry(1, 12, 12);
                    const eagleBodyMaterial = new THREE.MeshStandardMaterial({ color: 0x8a5a44 });
                    const eagleBody = new THREE.Mesh(eagleBodyGeometry, eagleBodyMaterial);
                    group.add(eagleBody);

                    // Head
                    const eagleHeadGeometry = new THREE.SphereGeometry(0.7, 10, 10);
                    const eagleHead = new THREE.Mesh(eagleHeadGeometry, eagleBodyMaterial);
                    eagleHead.position.set(0, 0, 1.2);
                    group.add(eagleHead);

                    // Beak
                    const beakGeometry = new THREE.ConeGeometry(0.2, 0.8, 6);
                    const beakMaterial = new THREE.MeshStandardMaterial({ color: 0xe8a040 });
                    const beak = new THREE.Mesh(beakGeometry, beakMaterial);
                    beak.position.set(0, 0, 1.8);
                    beak.rotation.x = Math.PI / 2;
                    group.add(beak);

                    // Wings (simplified)
                    const wingGeometry = new THREE.PlaneGeometry(4, 1.5, 1, 1);
                    const wingMaterial = new THREE.MeshStandardMaterial({
                        color: 0x5a3a24,
                        side: THREE.DoubleSide
                    });
                    const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                    leftWing.position.set(-2, 0, 0);
                    leftWing.rotation.y = Math.PI / 2;
                    leftWing.rotation.z = Math.PI / 4;
                    group.add(leftWing);

                    const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                    rightWing.position.set(2, 0, 0);
                    rightWing.rotation.y = Math.PI / 2;
                    rightWing.rotation.z = -Math.PI / 4;
                    group.add(rightWing);
                    break;

                // Other predators with similar optimizations...
                default:
                    // Default predator (sphere)
                    const predatorGeometry = new THREE.SphereGeometry(1.5, 12, 12);
                    const predatorMaterial = new THREE.MeshStandardMaterial({ color: 0x8a5a44 });
                    const predatorMesh = new THREE.Mesh(predatorGeometry, predatorMaterial);
                    group.add(predatorMesh);
            }

            predator = group;
            predator.position.copy(new THREE.Vector3(
                gameState.currentMission.predatorPosition.x,
                gameState.currentMission.predatorPosition.y,
                gameState.currentMission.predatorPosition.z
            ));
            scene.add(predator);

            // Create physics body for predator
            const predatorShape = new CANNON.Sphere(1.5);
            const predatorBody = new CANNON.Body({ mass: 1 });
            predatorBody.addShape(predatorShape);
            predatorBody.position.copy(predator.position);
            physicsWorld.addBody(predatorBody);

            return predator;
        }

        // Create optimized weather effects
        function createWeatherEffects() {
            const weather = WEATHER_DATA[gameState.currentMission.weather];

            if (weather.particleDensity <= 0) return;

            const particleCount = Math.floor(PERFORMANCE.particleCount * weather.particleDensity);
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = Math.random() * 200 - 100;
                positions[i * 3 + 1] = Math.random() * 100;
                positions[i * 3 + 2] = Math.random() * 200 - 100;

                sizes[i] = Math.random() * 0.5 + 0.1;
            }

            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                color: new THREE.Color(weather.particleColor),
                size: 0.1,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });

            weatherParticles = new THREE.Points(particles, material);
            scene.add(weatherParticles);
        }

        // Create lightning effect
        function createLightning() {
            const points = [];
            points.push(new THREE.Vector3(0, 50, 0));
            points.push(new THREE.Vector3(0, 0, 0));

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0
            });

            lightning = new THREE.Line(geometry, material);
            scene.add(lightning);

            return lightning;
        }

        // Initialize Game
        function init() {
            // Set up Three.js with performance settings
            initThreeJS();

            // Create lightning effect (hidden by default)
            createLightning();

            // Check for saved game
            loadGame();

            // Set up event listeners with passive where possible
            setupEventListeners();

            // Show main menu
            showMainMenu();

            // Start optimized animation loop
            animate();
        }

        function setupEventListeners() {
            // Keyboard controls (for desktop)
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;

                // Pause game with ESC
                if (e.key === 'Escape' && gameRunning) {
                    togglePause();
                }

                // Handle other keys
                if (e.key === 'ArrowLeft' || e.key === 'a') controls.left = true;
                if (e.key === 'ArrowRight' || e.key === 'd') controls.right = true;
                if (e.key === 'ArrowUp' || e.key === 'w') controls.up = true;
                if (e.key === ' ' || e.key === 'Spacebar') controls.action = true;
                if (e.key === 'm' || e.key === 'M') controls.menu = true;
                
                // Food consumption shortcuts
                if (e.key === '1') consumeFood('apple');
                if (e.key === '2') consumeFood('meat');
                if (e.key === '3') consumeFood('mushroom');
            }, { passive: true });

            window.addEventListener('keyup', (e) => {
                keys[e.key] = false;

                if (e.key === 'ArrowLeft' || e.key === 'a') controls.left = false;
                if (e.key === 'ArrowRight' || e.key === 'd') controls.right = false;
                if (e.key === 'ArrowUp' || e.key === 'w') controls.up = false;
                if (e.key === ' ' || e.key === 'Spacebar') controls.action = false;
                if (e.key === 'm' || e.key === 'M') controls.menu = false;
            }, { passive: true });

            // Touch controls (for mobile)
            if (window.innerWidth <= 768) {
                // Joystick controls
                elements.joystick.addEventListener('touchstart', handleJoystickStart, { passive: false });
                elements.joystick.addEventListener('touchmove', handleJoystickMove, { passive: false });
                elements.joystick.addEventListener('touchend', handleJoystickEnd, { passive: false });
                
                // Action buttons
                buttons.up.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    controls.up = true;
                }, { passive: false });

                buttons.up.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    controls.up = false;
                }, { passive: false });

                buttons.action.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    controls.action = true;
                }, { passive: false });

                buttons.action.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    controls.action = false;
                }, { passive: false });

                buttons.menu.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    controls.menu = true;
                }, { passive: false });

                buttons.menu.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    controls.menu = false;
                }, { passive: false });
            }

            // Menu buttons
            buttons.newGame.addEventListener('click', startNewGame);
            buttons.continue.addEventListener('click', continueGame);
            buttons.mythicBook.addEventListener('click', showMythicBook);
            buttons.shop.addEventListener('click', showShop);
            buttons.shopFromPause.addEventListener('click', () => {
                togglePause();
                showShop();
            });
            buttons.settings.addEventListener('click', showSettings);
            buttons.resume.addEventListener('click', togglePause);
            buttons.saveExit.addEventListener('click', saveAndExit);
            buttons.bookFromPause.addEventListener('click', () => {
                togglePause();
                showMythicBook();
            });
            buttons.closeBook.addEventListener('click', hideMythicBook);
            buttons.closeDetail.addEventListener('click', hidePageDetail);
            buttons.continueJourney.addEventListener('click', continueJourney);
            buttons.musicToggle.addEventListener('click', toggleMusic);
            buttons.soundToggle.addEventListener('click', toggleSound);
            buttons.difficultyButton.addEventListener('click', changeDifficulty);
            buttons.autosaveToggle.addEventListener('click', toggleAutosave);
            buttons.controlsHelpButton.addEventListener('click', showControlsHelp);
            buttons.resetGameButton.addEventListener('click', resetGame);
            buttons.closeSettingsButton.addEventListener('click', hideSettings);
            buttons.closeShopButton.addEventListener('click', hideShop);
        }

        // Joystick controls for mobile
        function handleJoystickStart(e) {
            e.preventDefault();
            joystickActive = true;
            const touch = e.touches[0];
            const rect = elements.joystickArea.getBoundingClientRect();
            joystickStartPos = {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
        }

        function handleJoystickMove(e) {
            if (!joystickActive) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const rect = elements.joystickArea.getBoundingClientRect();
            const joystickPos = {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
            
            // Calculate relative position
            const deltaX = joystickPos.x - joystickStartPos.x;
            const deltaY = joystickPos.y - joystickStartPos.y;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = 50;
            
            // Normalize and limit joystick movement
            if (distance > maxDistance) {
                const angle = Math.atan2(deltaY, deltaX);
                controls.joystick.x = Math.cos(angle) * maxDistance;
                controls.joystick.y = Math.sin(angle) * maxDistance;
            } else {
                controls.joystick.x = deltaX;
                controls.joystick.y = deltaY;
            }
            
            // Update joystick visual position
            elements.joystick.style.transform = `translate(${controls.joystick.x}px, ${controls.joystick.y}px)`;
            
            // Convert joystick position to controls
            controls.left = controls.joystick.x < -20;
            controls.right = controls.joystick.x > 20;
            controls.up = controls.joystick.y < -20;
        }

        function handleJoystickEnd(e) {
            e.preventDefault();
            joystickActive = false;
            controls.joystick = { x: 0, y: 0 };
            controls.left = false;
            controls.right = false;
            controls.up = false;
            elements.joystick.style.transform = 'translate(0, 0)';
        }

        // Game State Management
        function loadGame() {
            const savedGame = localStorage.getItem('owlOfMythsSave');

            if (savedGame) {
                try {
                    const parsed = JSON.parse(savedGame);

                    // Basic validation
                    if (parsed.player && parsed.settings) {
                        gameState = parsed;
                        buttons.continue.style.display = 'block';

                        // Update UI to reflect loaded state
                        updateUI();
                        updateFoodUI();
                    }
                } catch (e) {
                    console.error("Failed to load saved game:", e);
                }
            } else {
                buttons.continue.style.display = 'none';
            }
        }

        function saveGame() {
            try {
                // Update player position before saving
                if (owl) {
                    gameState.player.position.x = owl.position.x;
                    gameState.player.position.y = owl.position.y;
                    gameState.player.position.z = owl.position.z;
                }

                localStorage.setItem('owlOfMythsSave', JSON.stringify(gameState));
            } catch (e) {
                console.error("Failed to save game:", e);
            }
        }

        function clearSavedGame() {
            localStorage.removeItem('owlOfMythsSave');
            buttons.continue.style.display = 'none';
        }

        // Menu Functions
        function showMainMenu() {
            elements.mainMenu.style.display = 'flex';
            elements.pauseMenu.style.display = 'none';
            elements.mythicBook.style.display = 'none';
            elements.missionComplete.style.display = 'none';
            elements.settingsMenu.style.display = 'none';
            elements.shopMenu.style.display = 'none';
            gameRunning = false;
        }

        function hideMainMenu() {
            elements.mainMenu.style.display = 'none';
        }

        function togglePause() {
            if (elements.pauseMenu.style.display === 'flex') {
                elements.pauseMenu.style.display = 'none';
                gameRunning = true;
            } else {
                elements.pauseMenu.style.display = 'flex';
                gameRunning = false;
            }
        }

        function showMythicBook() {
            elements.mythicBook.style.display = 'flex';
            renderMythicBook();
            gameRunning = false;
        }

        function hideMythicBook() {
            elements.mythicBook.style.display = 'none';
            gameRunning = true;
        }

        function showPageDetail(predator) {
            const data = PREDATOR_DATA[predator];

            elements.detailTitle.textContent = data.name;
            elements.detailContent.innerHTML = `
                <p><strong>Description:</strong> ${data.description}</p>
                <p><strong>Weakness:</strong> ${data.weakness}</p>
                <p><strong>Tactics:</strong> ${data.tactics}</p>
                <p><strong>Reward:</strong> ${data.reward} coins</p>
            `;

            elements.pageDetail.style.display = 'flex';
        }

        function hidePageDetail() {
            elements.pageDetail.style.display = 'none';
        }

        function renderMythicBook() {
            elements.pageContainer.innerHTML = '';

            PREDATORS.forEach(predator => {
                const isUnlocked = gameState.player.unlockedPages.includes(predator);
                const data = PREDATOR_DATA[predator];

                const page = document.createElement('div');
                page.className = `page ${isUnlocked ? 'page-unlocked' : ''}`;
                page.innerHTML = `
                    <div class="page-icon">${isUnlocked ? '📖' : '❓'}</div>
                    <div class="page-title">${data.name}</div>
                    <div class="page-status">${isUnlocked ? 'UNLOCKED' : 'LOCKED'}</div>
                `;

                if (isUnlocked) {
                    page.addEventListener('click', () => showPageDetail(predator));
                }

                elements.pageContainer.appendChild(page);
            });
        }

        function showSettings() {
            // Update toggle buttons to reflect current settings
            buttons.musicToggle.textContent = gameState.settings.music ? 'ON' : 'OFF';
            buttons.soundToggle.textContent = gameState.settings.sound ? 'ON' : 'OFF';
            buttons.difficultyButton.textContent = gameState.settings.difficulty.toUpperCase();
            buttons.autosaveToggle.textContent = gameState.settings.autoSave ? 'ON' : 'OFF';

            elements.settingsMenu.style.display = 'flex';
            gameRunning = false;
        }

        function hideSettings() {
            elements.settingsMenu.style.display = 'none';
            gameRunning = true;
        }

        function toggleMusic() {
            gameState.settings.music = !gameState.settings.music;
            buttons.musicToggle.textContent = gameState.settings.music ? 'ON' : 'OFF';

            if (gameState.settings.music) {
                audio.background.loop = true;
                audio.background.volume = 0.3;
                audio.background.play().catch(e => console.log("Audio play prevented:", e));
            } else {
                audio.background.pause();
            }

            saveGame();
        }

        function toggleSound() {
            gameState.settings.sound = !gameState.settings.sound;
            buttons.soundToggle.textContent = gameState.settings.sound ? 'ON' : 'OFF';
            saveGame();
        }

        function changeDifficulty() {
            const currentIndex = DIFFICULTIES.indexOf(gameState.settings.difficulty);
            const nextIndex = (currentIndex + 1) % DIFFICULTIES.length;
            gameState.settings.difficulty = DIFFICULTIES[nextIndex];
            buttons.difficultyButton.textContent = gameState.settings.difficulty.toUpperCase();
            saveGame();
        }

        function toggleAutosave() {
            gameState.settings.autoSave = !gameState.settings.autoSave;
            buttons.autosaveToggle.textContent = gameState.settings.autoSave ? 'ON' : 'OFF';
            saveGame();
        }

        function showControlsHelp() {
            alert(`Controls Help:
Keyboard Shortcuts:
- W/↑: Fly upward
- A/←: Move left
- D/→: Move right
- Space: Attack or interact
- M: Open pause menu
- ESC: Pause game
- 1/2/3: Consume food items

On mobile, use the on-screen joystick and buttons.`);
        }

        function resetGame() {
            if (confirm("Are you sure you want to reset the game? All progress will be lost.")) {
                clearSavedGame();
                location.reload();
            }
        }

        function showShop() {
            elements.shopCoinsValue.textContent = gameState.player.coins;
            renderShopItems();
            elements.shopMenu.style.display = 'flex';
            gameRunning = false;
        }

        function hideShop() {
            elements.shopMenu.style.display = 'none';
            gameRunning = true;
        }

        function renderShopItems() {
            elements.shopItems.innerHTML = '';

            SHOP_ITEMS.forEach(item => {
                const canAfford = gameState.player.coins >= item.price;
                const alreadyOwned = !item.consumable && gameState.player.upgrades[item.id];

                const shopItem = document.createElement('div');
                shopItem.className = 'shop-item';
                shopItem.innerHTML = `
                    <div class="item-icon">${item.icon}</div>
                    <div class="item-name">${item.name}</div>
                    <div class="item-price">${item.price} coins</div>
                    <button class="item-button" ${!canAfford || alreadyOwned ? 'disabled' : ''}>
                        ${alreadyOwned ? 'OWNED' : 'BUY'}
                    </button>
                `;

                const button = shopItem.querySelector('.item-button');
                if (!alreadyOwned && canAfford) {
                    button.addEventListener('click', () => purchaseItem(item));
                }

                elements.shopItems.appendChild(shopItem);
            });
        }

        function purchaseItem(item) {
            if (gameState.player.coins >= item.price) {
                gameState.player.coins -= item.price;
                item.effect(gameState);
                gameState.stats.coinsCollected += item.price;
                gameState.stats.upgradesPurchased++;

                // Play success sound
                if (gameState.settings.sound) {
                    audio.success.currentTime = 0;
                    audio.success.play().catch(e => console.log("Audio play prevented:", e));
                }

                // Update UI
                updateUI();
                renderShopItems();
                elements.shopCoinsValue.textContent = gameState.player.coins;

                // Save game
                if (gameState.settings.autoSave) {
                    saveGame();
                }
            }
        }

        function updateFoodUI() {
            elements.appleCount.textContent = gameState.player.inventory.apple || 0;
            elements.meatCount.textContent = gameState.player.inventory.meat || 0;
            elements.mushroomCount.textContent = gameState.player.inventory.mushroom || 0;
        }

        function consumeFood(foodType) {
            if (gameState.player.inventory[foodType] > 0) {
                const food = FOOD_DATA[foodType];
                
                // Apply effects
                gameState.player.health = Math.min(
                    gameState.player.maxHealth,
                    gameState.player.health + food.healthRestore
                );
                gameState.player.stamina = Math.min(
                    gameState.player.maxStamina,
                    gameState.player.stamina + food.staminaRestore
                );
                
                // Remove from inventory
                gameState.player.inventory[foodType]--;
                gameState.stats.foodConsumed++;
                
                // Play sound
                if (gameState.settings.sound) {
                    audio.eat.currentTime = 0;
                    audio.eat.play().catch(e => console.log("Audio play prevented:", e));
                }
                
                // Update UI
                updateUI();
                updateFoodUI();
                
                // Save game
                if (gameState.settings.autoSave) {
                    saveGame();
                }
            }
        }

        function showMissionComplete() {
            const predator = PREDATOR_DATA[gameState.currentMission.predator];
            elements.completeMessage.textContent = `You have captured the ${predator.name} and unlocked new knowledge! You earned ${predator.reward} coins.`;
            elements.missionComplete.style.display = 'flex';

            // Play success sound
            if (gameState.settings.sound) {
                audio.success.currentTime = 0;
                audio.success.play().catch(e => console.log("Audio play prevented:", e));
            }
        }

        // Game Functions
        function startNewGame() {
            // Reset game state
            gameState = {
                player: {
                    health: 100,
                    maxHealth: 100,
                    stamina: 100,
                    maxStamina: 100,
                    speed: 5,
                    coins: 0,
                    distance: 0,
                    position: { x: 0, y: 10, z: 0 },
                    velocity: { x: 0, y: 0, z: 0 },
                    upgrades: {
                        staminaRecovery: 1,
                        speed: 1,
                        vision: 1,
                        heatResistance: false,
                        coldResistance: false,
                        chameleonDetector: false
                    },
                    unlockedPredators: [],
                    unlockedPages: [],
                    inventory: {
                        apple: 0,
                        meat: 0,
                        mushroom: 0
                    }
                },
                currentMission: {
                    predator: null,
                    biome: null,
                    season: null,
                    weather: null,
                    started: false,
                    completed: false,
                    startTime: 0,
                    endTime: 0,
                    predatorPosition: { x: 50, y: 0, z: 0 },
                    predatorHealth: 0,
                    foodItems: []
                },
                settings: {
                    sound: true,
                    music: true,
                    difficulty: 'normal',
                    autoSave: true,
                    controls: 'buttons'
                },
                stats: {
                    totalDistance: 0,
                    predatorsCaptured: 0,
                    deaths: 0,
                    playTime: 0,
                    coinsCollected: 0,
                    upgradesPurchased: 0,
                    foodConsumed: 0
                }
            };

            // Start first mission
            startNewMission();

            // Hide menu and start game
            hideMainMenu();
            gameRunning = true;

            // Start background music if enabled
            if (gameState.settings.music) {
                audio.background.loop = true;
                audio.background.volume = 0.3;
                audio.background.play().catch(e => console.log("Audio play prevented:", e));
            }
        }

        function continueGame() {
            // If no current mission, start a new one
            if (!gameState.currentMission.predator || gameState.currentMission.completed) {
                startNewMission();
            }

            // Hide menu and start game
            hideMainMenu();
            gameRunning = true;

            // Start background music if enabled
            if (gameState.settings.music) {
                audio.background.loop = true;
                audio.background.volume = 0.3;
                audio.background.play().catch(e => console.log("Audio play prevented:", e));
            }
        }

        function startNewMission() {
            // Select a random predator (excluding already captured ones if we want)
            const availablePredators = PREDATORS.filter(p => !gameState.player.unlockedPredators.includes(p));
            const predator = availablePredators.length > 0 ?
                availablePredators[Math.floor(Math.random() * availablePredators.length)] :
                PREDATORS[Math.floor(Math.random() * PREDATORS.length)];

            // Select biome based on predator preference
            const biome = PREDATOR_DATA[predator].biome;

            // Select random season and weather
            const season = SEASONS[Math.floor(Math.random() * SEASONS.length)];

    // Ensure weather is valid
    const availableWeathers = Object.keys(WEATHER_DATA).filter(k => k !== 'default');
    const weather = availableWeathers[Math.floor(Math.random() * availableWeathers.length)];
    

            // Update game state
            gameState.currentMission = {
                predator,
                biome,
                season,
                weather,
                started: true,
                completed: false,
                startTime: Date.now(),
                endTime: 0,
                predatorPosition: {
                    x: 50 + Math.random() * 30 - 15,
                    y: 0,
                    z: Math.random() * 30 - 15
                },
                predatorHealth: PREDATOR_DATA[predator].health,
                foodItems: []
            };

            // Clear previous scene
            clearScene();

            // Create new environment
            createTerrain();
            createOwl();
            createPredator();
            createWeatherEffects();

            // Update UI
            updateUI();
            updateEnvironmentInfo();
            updateFoodUI();
        }

        function clearScene() {
            // Remove all objects from scene except camera and lights
            while (scene.children.length > 0) {
                const obj = scene.children[0];
                if (obj !== camera && obj !== directionalLight && obj !== ambientLight && obj !== hemisphereLight) {
                    scene.remove(obj);
                }
            }

            // Clear physics world
            while (physicsWorld.bodies.length > 0) {
                physicsWorld.removeBody(physicsWorld.bodies[0]);
            }

            // Reinitialize ground plane
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0 });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            physicsWorld.addBody(groundBody);
        }

        function completeMission() {
            gameState.currentMission.completed = true;
            gameState.currentMission.endTime = Date.now();

            // Add to captured predators if not already
            if (!gameState.player.unlockedPredators.includes(gameState.currentMission.predator)) {
                gameState.player.unlockedPredators.push(gameState.currentMission.predator);
                gameState.player.unlockedPages.push(gameState.currentMission.predator);
                gameState.stats.predatorsCaptured++;
            }

            // Reward coins
            const reward = PREDATOR_DATA[gameState.currentMission.predator].reward;
            gameState.player.coins += reward;
            gameState.stats.coinsCollected += reward;

            // Update stats
            gameState.stats.totalDistance += gameState.player.distance;
            gameState.stats.playTime += (gameState.currentMission.endTime - gameState.currentMission.startTime) / 1000;

            // Save game
            if (gameState.settings.autoSave) {
                saveGame();
            }

            // Show mission complete screen
            showMissionComplete();
        }

        function continueJourney() {
            elements.missionComplete.style.display = 'none';
            startNewMission();
            gameRunning = true;
        }

        function saveAndExit() {
            saveGame();
            togglePause();
            showMainMenu();

            // Stop background music
            audio.background.pause();
        }

        function updateUI() {
            // Update health and stamina bars
            elements.healthBar.style.width = `${(gameState.player.health / gameState.player.maxHealth) * 100}%`;
            elements.staminaBar.style.width = `${(gameState.player.stamina / gameState.player.maxStamina) * 100}%`;

            // Update other values
            elements.distanceValue.textContent = `${Math.round(gameState.player.distance)} KM`;

            if (gameState.currentMission.predator) {
                elements.targetValue.textContent = PREDATOR_DATA[gameState.currentMission.predator].name.toUpperCase();
            } else {
                elements.targetValue.textContent = "-";
            }

            elements.coinsValue.textContent = gameState.player.coins;
        }

        function updateEnvironmentInfo() {
            if (gameState.currentMission.biome) {
                elements.biomeValue.textContent = BIOME_DATA[gameState.currentMission.biome].name.toUpperCase();
            } else {
                elements.biomeValue.textContent = "-";
            }

            if (gameState.currentMission.season) {
                elements.seasonValue.textContent = SEASON_DATA[gameState.currentMission.season].name.toUpperCase();
            } else {
                elements.seasonValue.textContent = "-";
            }

            if (gameState.currentMission.weather) {
                elements.weatherValue.textContent = WEATHER_DATA[gameState.currentMission.weather].name.toUpperCase();
            } else {
                elements.weatherValue.textContent = "-";
            }
        }

        function handleInput() {
            if (!gameRunning || !owl) return;

            // Handle movement with joystick or keyboard
            const speed = gameState.player.speed * 0.1;
            const staminaCost = 0.1;
            
            // Use joystick controls if active, otherwise use keyboard
            if (joystickActive) {
                if (controls.joystick.x < -20) {
                    owl.position.x -= speed;
                    gameState.player.stamina = Math.max(0, gameState.player.stamina - staminaCost);
                }
                if (controls.joystick.x > 20) {
                    owl.position.x += speed;
                    gameState.player.stamina = Math.max(0, gameState.player.stamina - staminaCost);
                }
                if (controls.joystick.y < -20) {
                    owl.position.y += speed;
                    gameState.player.stamina = Math.max(0, gameState.player.stamina - staminaCost * 1.5);
                }
            } else {
                // Keyboard controls
                if (controls.left && gameState.player.stamina > 0) {
                    owl.position.x -= speed;
                    gameState.player.stamina = Math.max(0, gameState.player.stamina - staminaCost);
                }

                if (controls.right && gameState.player.stamina > 0) {
                    owl.position.x += speed;
                    gameState.player.stamina = Math.max(0, gameState.player.stamina - staminaCost);
                }

                if (controls.up && gameState.player.stamina > 0) {
                    owl.position.y += speed;
                    gameState.player.stamina = Math.max(0, gameState.player.stamina - staminaCost * 1.5);
                }
            }

            // Gravity - always pull down unless up is pressed
            if (!controls.up && !(joystickActive && controls.joystick.y < -20)) {
                owl.position.y -= speed * 0.5;
            }

            // Ensure owl doesn't go below terrain
            const terrainHeight = getTerrainHeight(owl.position.x, owl.position.z);
            if (owl.position.y < terrainHeight + 1.5) {
                owl.position.y = terrainHeight + 1.5;
            }

            // Action button - attack or collect food
            if (controls.action) {
                // Check if close enough to predator
                if (predator && gameState.player.stamina > 10) {
                    const distance = owl.position.distanceTo(predator.position);
                    if (distance < 5) {
                        // Attack predator
                        gameState.currentMission.predatorHealth -= 10 + Math.random() * 10;
                        gameState.player.stamina -= 10;

                        // Play damage sound
                        if (gameState.settings.sound) {
                            audio.damage.currentTime = 0;
                            audio.damage.play().catch(e => console.log("Audio play prevented:", e));
                        }

                        // Check if predator is defeated
                        if (gameState.currentMission.predatorHealth <= 0) {
                            completeMission();
                            gameRunning = false;
                        }
                    }
                }
                
                // Check for nearby food items
                gameState.currentMission.foodItems.forEach(food => {
                    if (!food.collected) {
                        const foodPos = new THREE.Vector3(food.position.x, food.position.y, food.position.z);
                        const distance = owl.position.distanceTo(foodPos);
                        
                        if (distance < 3) {
                            food.collected = true;
                            gameState.player.inventory[food.type] = (gameState.player.inventory[food.type] || 0) + 1;
                            updateFoodUI();
                            
                            // Play collection sound
                            if (gameState.settings.sound) {
                                audio.success.currentTime = 0;
                                audio.success.play().catch(e => console.log("Audio play prevented:", e));
                            }
                            
                            // Remove food visual from scene
                            scene.children.forEach(child => {
                                if (child.userData?.foodItem === food) {
                                    scene.remove(child);
                                }
                            });
                        }
                    }
                });
            }

            // Menu button
            if (controls.menu) {
                togglePause();
                controls.menu = false; // Prevent continuous toggling
            }

            // Stamina recovery
            if (!controls.left && !controls.right && !controls.up && !joystickActive) {
                gameState.player.stamina = Math.min(
                    gameState.player.maxStamina,
                    gameState.player.stamina + 0.2 * gameState.player.upgrades.staminaRecovery
                );
            }

            // Update distance (based on z position)
            gameState.player.distance = Math.max(gameState.player.distance, Math.abs(owl.position.z) / 10);

            // Update UI
            updateUI();

            // Move predator (simple AI)
            if (predator && !gameState.currentMission.completed) {
                // Simple chase behavior
                const predatorInfo = PREDATOR_DATA[gameState.currentMission.predator];
                const speed = predatorInfo.speed * 0.05;

                // Move toward owl
                const direction = new THREE.Vector3().subVectors(owl.position, predator.position).normalize();
                predator.position.add(direction.multiplyScalar(speed));

                // For flying predators (eagle), adjust y position
                if (gameState.currentMission.predator === 'eagle') {
                    predator.position.y = owl.position.y + (Math.sin(Date.now() * 0.001) * 3);
                }

                // Check if predator caught owl
                const distance = owl.position.distanceTo(predator.position);
                if (distance < 3) {
                    // Owl takes damage
                    gameState.player.health -= 5 + Math.random() * 5;

                    // Play damage sound
                    if (gameState.settings.sound) {
                        audio.damage.currentTime = 0;
                        audio.damage.play().catch(e => console.log("Audio play prevented:", e));
                    }

                    // Check if owl is dead
                    if (gameState.player.health <= 0) {
                        gameState.player.health = 0;
                        gameState.stats.deaths++;

                        // Reset position
                        owl.position.set(0, 10, 0);
                        gameState.player.health = gameState.player.maxHealth;
                        gameState.player.stamina = gameState.player.maxStamina;

                        // Save game
                        if (gameState.settings.autoSave) {
                            saveGame();
                        }
                    }
                }
            }
        }

function animateLightning() {
    if (!lightning) return;

    // Safely get weather data with fallback
    const weather = WEATHER_DATA[gameState.currentMission.weather] || WEATHER_DATA.default;
    
    // Check if lightningChance exists and is > 0
    const lightningChance = weather.lightningChance || 0;
    if (lightningChance > 0 && Math.random() < lightningChance) {
        // Show lightning
        lightning.material.opacity = 0.8;

        // Play thunder sound
        if (gameState.settings.sound) {
            audio.thunder.currentTime = 0;
            audio.thunder.play().catch(e => console.log("Audio play prevented:", e));
        }

        // Hide after short delay
        setTimeout(() => {
            if (lightning) lightning.material.opacity = 0;
        }, 100);
    }
}

        function animateWeather() {
            if (!weatherParticles) return;

            const weather = WEATHER_DATA[gameState.currentMission.weather];
            if (weather.particleDensity > 0) {
                // Animate particles falling
                const positions = weatherParticles.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] -= weather.particleSpeed * 0.5;

                    // Reset particles that fall below
                    if (positions[i + 1] < 0) {
                        positions[i] = Math.random() * 200 - 100;
                        positions[i + 1] = 100;
                        positions[i + 2] = Math.random() * 200 - 100;
                    }
                }

                weatherParticles.geometry.attributes.position.needsUpdate = true;
            }
        }

        // Optimized animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Only update physics and input when game is running
            if (gameRunning) {
                // Update physics with fixed time step
                const deltaTime = Math.min(0.1, clock.getDelta()); // Cap delta time
                physicsWorld.step(fixedTimeStep, deltaTime, maxSubSteps);

                // Handle input
                handleInput();
            }

            // Update camera to follow owl
            if (owl) {
                camera.position.x = owl.position.x;
                camera.position.z = owl.position.z + 30;
                camera.lookAt(owl.position.x, owl.position.y + 5, owl.position.z); // Look slightly above owl

                // Animate wings when flying
                if (controls.up || (joystickActive && controls.joystick.y < -20)) {
                    const wings = owl.children.filter(child => 
                        child.geometry instanceof THREE.SphereGeometry && 
                        child.material.color.getHex() === 0x6a4a34
                    );
                    wings.forEach(wing => {
                        wing.rotation.x = Math.sin(Date.now() * 0.01) * 0.5;
                    });
                }
            }

            // Animate predator if it exists
            if (predator && !gameState.currentMission.completed) {
                // Simple idle animation
                if (gameState.currentMission.predator === 'eagle') {
                    // Flap wings
                    const wings = predator.children.filter(child => 
                        child.geometry instanceof THREE.PlaneGeometry
                    );
                    wings.forEach(wing => {
                        wing.rotation.z = Math.sin(Date.now() * 0.01) * 0.5;
                    });
                } else if (gameState.currentMission.predator === 'snake') {
                    // Wiggle snake
                    const segments = predator.children;
                    for (let i = 0; i < segments.length; i++) {
                        segments[i].position.x += Math.sin(Date.now() * 0.001 + i * 0.3) * 0.01;
                        segments[i].position.z += Math.cos(Date.now() * 0.001 + i * 0.3) * 0.01;
                    }
                }
            }

            // Animate weather effects if game is running
            if (gameRunning) {
                animateWeather();
                animateLightning();
            }

            // Render scene
            renderer.render(scene, camera);
        }

        // Initialize the game when the page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>